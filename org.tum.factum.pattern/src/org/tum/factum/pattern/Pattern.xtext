grammar org.tum.factum.pattern.Pattern with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore 

generate pattern "http://www.tum.org/factum/pattern/Pattern"

Pattern returns Pattern:
	{Pattern} 
	'Pattern' name=EString
	'ShortName' psname=EString
	'{'
		('DTSpec' '{' dtSpec+=DataTypeSpec( "," dtSpec+=DataTypeSpec)* '}' )?
			
		('ComponentTypes' '{' componentTypes+=ComponentType	( "," componentTypes+=ComponentType)* '}' )?
	    
	    ('Interfaces' '{' hasInterfaces+=Interface ( "," hasInterfaces+=Interface)* '}' )?
	    
	    //('archConstraints' '{' (cmpd+=CompDeclaration)* (cmpA+=ComponentAssignment)* (archConstraints= AC | acFunction= ArchitectureConstraint?) ('act''('ComponentType=[ComponentType|QualifiedName]')')? '}' )?
	  	//('archConstraints' '{' (cmps+=Component ("," cmps+=Component)*)? (cmp+=[Component|QualifiedName]+) (archConstraints= AC | acFunction= ArchitectureConstraint?) ('act''('ComponentType=[ComponentType|QualifiedName]')')? '}' )?
	  
	    ('archConstraints' '{' 
	    	(cmps+=Component ("," cmps+=Component)*)? 
	    	
	    	//(prtref+=Portref)?
	    	//(inputPortA=[InputPort|QualifiedName])?   
	    	
	    	(archConstraints= AC | acFunction= ArchitectureConstraint?) 
	    	
	    	//('act''('ComponentType=[ComponentType|QualifiedName]')')?
	    	
	    	'}'
	    )?
	    
		('SubPattern' '{' SubPattern+=Pattern ( "," SubPattern+=Pattern)* '}' )?
	'}'
;
ComponentType returns ComponentType:
	{ComponentType} 
	'ComponentType' 
	name=EString
	'{'
		('shortName' ctsname=EString)?
		('comment' comment=EString)?
		('hasEdges' '{' hasEdges+=Interface ( "," hasEdges+=Interface)* '}' )?  
		//('iParameters' '{' iParameters+=InterfaceParameter ( "," iParameters+=InterfaceParameter)* '}' )?
		
	    ('inputPorts' '{' inputports=InputPort '}' )?
	    //('inputPorts' '{' inputports+=InputPort ( "," inputports+=InputPort)* '}' )?
	    ('outputPorts' '{' outputports=OutputPort '}' )?
	    	    
	    ('bAssertions' '{' (bAssertions= BA | btaFunction=BehaviorTraceAssertion?) '}' )?
	
	'}'
;
Component returns Component:
	{Component}
	'Component'	name=QualifiedName ':' cmptypAssigned=[ComponentType|QualifiedName]?
;

Portref returns Portref:
	{Portref}
	cmp=[Component|ID] '.' prt=[InputPort|ID]
	
   //cmp=[Component|ID] '.' (prt1=[InputPort|ID] | prt2=[OutputPort])
;
Interface returns Interface:
	{Interface}	'Interface'
	'{'
		('name' name=EString)?
		('comment' comment=EString)?
		//('hasEdges' '{' hasEdges+=Interface ( "," hasEdges+=Interface)* '}' )?
		('Type' ':' sort=[Sort| QualifiedName])
	    ('hasInput' hasInput=[InputPort])
	    ('hasOutput' hasOutput=[OutputPort])
	'}'
;
OutputPort returns OutputPort:
	{OutputPort} 
	'OutputPort' name=EString
	'('
		('comment' comment=EString)?
		('portType' portType=[PortDataType|EString])?
		('Type' ':' sort=[Sort| QualifiedName])
	    ('connects' connects=[InputPort])?
			
	')'
;
InputPort returns InputPort:
	{InputPort}	
	'InputPort' name=EString
	'('
		('comment' comment=EString)?
		('Type' ':' sort=[Sort| QualifiedName])
		('portType' portType=[PortDataType|EString])?
	    ('connects' connects=[OutputPort])?
	')'
;
PortDataType returns PortDataType:
	{PortDataType} 
	//'PortDataType'
	//'('
		('name' name=EString)?
		('comment' comment=EString)?
		('type' type=EString)?
		//('outputPorts' outputPorts=[OutputPort|EString])?
		//('inputPorts' inputPorts=[OutputPort|EString])?
		('dataTypeAssertions' '(' dataTypeAssertions+=[DataTypeAssertion|EString] ( "," dataTypeAssertions+=[DataTypeAssertion|EString])* ')' )?
	//')'
;
DataTypeAssertion returns DataTypeAssertion:
	{DataTypeAssertion}
	'DataTypeAssertion'
	'{'
		('name' name=EString)?
		('comment' comment=EString)?
	'}'
;
DataTypeSpec returns DataTypeSpec:
	{DataTypeSpec}	
	'DataType' name =ID	'('
		'Sort' (sorts+=Sort ("," sorts+=Sort)*)?
		'Operation' (op+=Operation ("," op+=Operation)*)?
	')'
;
Operation:
	name=ID ':'  (dtInput+=[Sort|QualifiedName] ("," dtInput+=[Sort|QualifiedName])*)? '=>' (dtOutput=[Sort|QualifiedName])?
	//(dtInput+=DTInput ("," dtInput+=DTInput)*)? '=>' (dtOutput=DTOutput)?
;
Sort:
	name=ID
;
btaExpression:
	BehaviorTraceAssertion
; 
BehaviorTraceAssertion returns btaExpression:
	LtlOp '(' asertion=btaFunction ')'
;
btaFunction returns btaExpression:
	btaExpression |
	BA
;
BA:
	inputPortA=[InputPort|QualifiedName] '=' outputPortA=[OutputPort|QualifiedName]
;
acExpression:
	ArchitectureConstraint
;
ArchitectureConstraint	returns acExpression:
	LtlOp '(' asertion=archConstFunction ')'
	//( LtlOp '(' AC ')')? 
	//('act''('Component=[Component|EString]')')?
;
archConstFunction:
	acExpression |
	AC
;
AC:
	InputPort=[InputPort|QualifiedName] '=' OutputPort=[OutputPort|QualifiedName]
;
LtlOp:
	('G' | 'X' | 'F')
;
QualifiedName:
    ID ('.' ID)*
;	
EString returns ecore::EString:
	STRING | ID
;