grammar org.tum.factum.pattern.Pattern with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate pattern "http://www.tum.org/factum/pattern/Pattern"

Pattern returns Pattern:
	{Pattern} 
	'Pattern' name=ID 'ShortName' psname=ID
	'{'
		('DTSpec' '{' dtSpec+=DataTypeSpec( "," dtSpec+=DataTypeSpec)* '}' )?
		('CTypes' '{' componentTypes+=ComponentType	( "," componentTypes+=ComponentType)* '}' )?
 
	    ('ArchSpec' '{' 
	    	(ctaCmpVar+=ComponentVariable ("," ctaCmpVar+=ComponentVariable)*) 			//Declaration of Component Variables
	    	ctaDtVars=DTVariables 														//Declaration of DT Variables
	    	
			(ctaFormulaIds+=CtaFormulasID)*
	    	'}'
	    )?
	    
	    ('ArchGuarantee' '{'
			(agCmpVar+=ComponentVariable ("," agCmpVar+=ComponentVariable)*)
			agDtVars=DTVariables
			
			(agFormulas+=AgFormulasID)*
	    '}')?
	    
		('SubPattern' '{' SubPattern+=Pattern ( "," SubPattern+=Pattern)* '}' )?
	'}'
;
ComponentType returns ComponentType:
	{ComponentType} 
	'CType'	name=ID ('ShortName' ctsname=ID)? 
	'{'
	    ('InputPorts' '{' inputPorts+=InputPort ( "," inputPorts+=InputPort)* '}' )?
	    ('OutputPorts' '{' outputPorts+=OutputPort ( "," outputPorts+=OutputPort)* '}' )?
	    
	    ('BTA' '{' //Behavior Trace Assertions (BTA)
	    	(btaDtVar+=DataTypeVariable ("," btaDtVar+=DataTypeVariable)*)?
	    	
			(btaFormulaIds+=BtaFormulasID)*
	    )?
	'}'
;
OutputPort returns OutputPort:
	{OutputPort} 
	'OutputPort' name=EString '(' 
		('Type' ':' outputPrtSrtTyp=[Sort|QualifiedName]) 
		('connects' connects+=[InputPort|QualifiedName]*)?
	')'
;
InputPort returns InputPort:
	{InputPort}	
	'InputPort' name=ID '('
		('Type' ':' inputPrtSrtTyp=[Sort|QualifiedName])
	    ('connects' connects+=[OutputPort|QualifiedName]*)?
	')'
;
DataTypeSpec returns DataTypeSpec:
	{DataTypeSpec}	
	'DT' name =ID	'('
		'Sort' (dtSorts+=Sort ("," dtSorts+=Sort)*)?
		('Operation' (dtOps+=Operation ("," dtOps+=Operation)*))?
		('Predicate' (dtPredicate+=DTPredicate ("," dtPredicate+=DTPredicate)*))?
		(sortName=[Sort|ID] 'generatedBy' (returnOps+=[Operation|ID] ("," returnOps+=[Operation|ID])*))?		
	')'
;
DTPredicate:
	name=ID ':' (pInput+=[Sort|QualifiedName] ("," pInput+=[Sort|QualifiedName])*)?
;
Operation:
	name=ID ':'  (dtInput+=[Sort|QualifiedName] ("," dtInput+=[Sort|QualifiedName])*)? '=>' (dtOutput=[Sort|QualifiedName])?
;
Sort:
	name=ID
;
//Begin common rules for CTA, Architectural Guarantee(AG) and Behavior Trace Assertions (BTA)
VariableStatus: 
	'rig' | 'flex'
;
ComponentVariable:
	VariableStatus	name=ID ':' cmptypAssigned=[ComponentType|ID]?
;
DataTypeVariable: 
	VariableStatus name=ID ':' varSortType=[Sort|QualifiedName]
;
DTVariables:
	(dtVars+=DataTypeVariable ("," dtVars+=DataTypeVariable)*)
;
PortRef:
	InputPort | OutputPort
;
CmpVariableRef:
	cmpRef=[ComponentVariable|ID] '.' portRef=[PortRef|ID]
;
Terms:
	DataTypeVariable 
;
Term: 
	terms=[Terms|ID] | CmpVariableRef | termOperatorFunction=TermOperatorFunction
;
TermOperatorFunction:
	trmOperator=[Operation|QualifiedName] "(" (trmOperands+=Term ("," trmOperands+=Term)*) ")" 
;
//End

//Begin Configuration Trace Assertions(CTA) - Architectural Configuration or Configuration Trace Assertion 
CtaRefComponentVariableInputPort:
	inptPrtCmpRef=[ComponentVariable|ID] '.' inputPrtrf=[InputPort|ID]
;
CtaRefComponentVariableOutputPort:
	outptPrtCmpRef=[ComponentVariable|ID] '.' outputPrtrf=[OutputPort|ID]
;
CtaPredicateTerms:
	ctaPTerm1=Term equalityOperator=EqualityElementOperator ctaPTerm2=Term
;
CtaPredicateConn: 
	ctaConn='conn' ('(' ctaConnCmpVarOutputPort=CtaRefComponentVariableOutputPort ','	ctaConnCmpVarInptPort=CtaRefComponentVariableInputPort ')')
;
CtaPredicateEq: 
	ctaEq='eq' ('(' ctaComponentVariable+=[ComponentVariable|ID] ',' ctaComponentVariable+=[ComponentVariable|ID] ')')
;
CtaPredicateVal:
	ctaVal='val' ('(' valCtaCmpVaref=CmpVariableRef ',' ctaValTerms=Term ')') 
;
CtaPredicate:
	cAct='cAct' ('('cActCmpVar=[ComponentVariable|ID] ')') |
	pAct='pAct' ('(' pActCtaCmpVaref=CmpVariableRef ')') 
;
CtaUnaryFormulas:
	unaryOperator=UnaryOperator  ctaFormulaLtl=CtaFormula
;
CtaBinaryFormulas:
	'('(ctaFormulaLgk+=CtaFormula (BinaryOperator ctaFormulaLgk+=CtaFormula)*) ')'
;
CtaQuantifiedFormulas:
	quantifierOperator=QuantifierOperator ctaQuantifiedFs=CtaFormula 
;
CtaFormula:
	ctaPredicateTerms=CtaPredicateTerms | 
	ctaPredicateConn=CtaPredicateConn | 
	ctaPredicateVal=CtaPredicateVal | 
	ctaPredicateEq=CtaPredicateEq | 
	ctaPredicate=CtaPredicate | 
	
	ctaUnaryFormulas=CtaUnaryFormulas | 
	ctaBinaryFormulas=CtaBinaryFormulas |  
	ctaQuantifiedFormulas=CtaQuantifiedFormulas
;
CtaFormulasID:
	name=ID ':' ctaFormula=CtaFormula
;
// End CTA

// Begin Architectural Guarantee
AgRefComponentVariableInputPort:
	inptPrtCmpRef=[ComponentVariable|ID] '.' inputPrtrf=[InputPort|ID]
;
AgRefComponentVariableOutputPort:
	outptPrtCmpRef=[ComponentVariable|ID] '.' outputPrtrf=[OutputPort|ID]
;
AgPredicateTerms:
	agPTerm1=Term equalityOperator=EqualityElementOperator agPTerm2=Term
;
AgPredicateEq: 
	agEq='eq' ('(' agComponentVariable+=[ComponentVariable|ID] ',' agComponentVariable+=[ComponentVariable|ID] ')')
;
AgPredicateConn: 
	agConn='conn' ('(' agConnCmpVarOutputPort=AgRefComponentVariableOutputPort ','	agConnCmpVarInptPort=AgRefComponentVariableInputPort ')')
;
AgPredicateVal:
	agVal='val' ('(' valAgRefComponentVariable=CmpVariableRef ',' agValTerms=TermOperatorFunction ')') //the terms have to be the same type of the component port
;
AgPredicate:
	agcAct='cAct' ('('agcActCmpVar=[ComponentVariable|ID] ')') |
	agpAct='pAct' ('(' agpActCtaCmpVaref=CmpVariableRef ')') 
;
AgUnaryFormulas:
	unaryOperator=UnaryOperator  agFormulaLtl=AgFormula
;
AgBinaryFormulas:
	'('(agFormulaLgk+=AgFormula (BinaryOperator agFormulaLgk+=AgFormula)*) ')'
;
AgQuantifiedFormulas:
	agQuantifierOperator=QuantifierOperator agQuantifiedFs=AgFormula 
;
AgFormula:
	gaPredicateTerms=AgPredicateTerms | 
	agPredicateConn=AgPredicateConn | 
	agPredicateVal=AgPredicateVal | 
	agPredicateEq=AgPredicateEq | 
	agPredicate=AgPredicate | 
	
	agUnaryFormulas=AgUnaryFormulas | 
	agBinaryFormulas=AgBinaryFormulas | 
	agQuantifiedFormulas=AgQuantifiedFormulas
;
AgFormulasID:
	name=ID ':' agFormula=AgFormula
;
// End AG

// Begin Behavior Trace Assertions(BTA) 
BtaTerms:
	prtRef=PortRef | DataTypeVariable	
;
BtaTermOperatorFunction:
	btaTrmOperator=[Operation|QualifiedName] "(" (btaTrmOperands+=BtaTerm ("," btaTrmOperands+=BtaTerm)*) ")"
;
BtaTerm:
	btaTerms=[BtaTerms|ID] | btaTrmOperatorFunction=BtaTermOperatorFunction
;
BtaPredicate:
	(btaTerm1=BtaTerm EqualityElementOperator btaTerm2=BtaTerm) 
;
BtUrinaryFormulas:
	UnaryOperator  btaFormulaLtl=BtaFormula
;
BtaBinaryFormulas:
	'('(btaFormulaLgk+=BtaFormula (BinaryOperator btaFormulaLgk+=BtaFormula)*) ')' //try with brackets for better non LL
;
BtaQuantifiedFormulas:
	QuantifierOperator btaQuantifiedFs=BtaFormula 
;
BtaFormula:
	BtaPredicate | 
	BtUrinaryFormulas | 
	BtaBinaryFormulas |  
	BtaQuantifiedFormulas
;
BtaFormulasID:
	name=ID ':' btaFormula=BtaFormula
;
//End BTA

//Begin Operator rules for CTA, BTA, and AG ....
UnaryOperator: 
	ltlG='G' | ltlX='X' |	ltlF='F' | //Linear Temporal Logic Operators
	neg='¬' // Negation logic operator 
;
BinaryOperator: 
	'⇒' | '∧' | '∨' | '⇔' | 'W' | 'U' //operates F and F, F is a formula (CtaFormula,  AgFormula, and BtaFormula)
;
EqualityElementOperator: //Maybe not needed (check?)
	'='
;
QuantifiedVariables:
	DataTypeVariable | ComponentVariable
;
QuantifierOperator:
	exists='∃'(quantifiedExistsDtVar=[DataTypeVariable|ID]'.') | all='∀'(quantifiedAllDtVar=[QuantifiedVariables|ID]'.')
;
//End
QualifiedName:
    ID ('.' ID)*
;
EString returns ecore::EString:
	STRING | ID
;
	
