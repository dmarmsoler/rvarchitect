grammar org.tum.factum.pattern.Pattern with org.eclipse.xtext.common.Terminals

generate pattern "http://www.tum.org/factum/pattern/Pattern"

Pattern returns Pattern:
	{Pattern} 
	'Pattern' name=ID 'ShortName' psname=ID
	'{'
		('DTSpec' '{' dtSpec+=DataTypeSpec( "," dtSpec+=DataTypeSpec)* '}' )?
		('ComponentTypes' '{' componentTypes+=ComponentType	( "," componentTypes+=ComponentType)* '}' )?
   
	    //('archConstraints' '{' (cmpd+=CompDeclaration)* (cmpA+=ComponentAssignment)* (archConstraints= AC | acFunction= ArchitectureConstraint?) ('act''('ComponentType=[ComponentType|QualifiedName]')')? '}' )?
	  	//('archConstraints' '{' (cmps+=Component ("," cmps+=Component)*)? (cmp+=[Component|QualifiedName]+) (archConstraints= AC | acFunction= ArchitectureConstraint?) ('act''('ComponentType=[ComponentType|QualifiedName]')')? '}' )?
	  
	    ('archConstraints' '{' 
	    	(cmps+=Component ("," cmps+=Component)*)? 
	    	
   	
	    	(ref+=Portref ("," ref+=Portref)*)?
	    	
	    	(archConstraints= AC | acFunction= ArchitectureConstraint)? //Importnat - this line is stoping the above line 
	    	
	    	//('act''('ComponentType=[ComponentType|QualifiedName]')')?
	    	
	    	'}'
	    )?
		('SubPattern' '{' SubPattern+=Pattern ( "," SubPattern+=Pattern)* '}' )?
	'}'
;

ComponentType returns ComponentType:
	{ComponentType} 
	'CType'	name=ID ('ShortName' ctsname=ID)? 
	'{'
	    ('InputPorts' '{' inputPorts+=InputPort ( "," inputPorts+=InputPort)* '}' )?
	    ('OutputPorts' '{' outputPorts+=OutputPort ( "," outputPorts+=OutputPort)* '}' )?
	    ('bAssertions' '{' 
	    	(bAssertions= BA | btaFunction=BehaviorTraceAssertion?) '}'
	    )?
	
	'}'
;

Component:
	'Component'	name=ID ':' cmptypAssigned=[ComponentType|ID]?
;
Portref:
	cmp2=[Component|ID] '.' p2=[InputPort|ID]	
   //cmp=[Component|ID] '.' (prt1=[InputPort|ID] | prt2=[OutputPort])
;
Interface returns Interface:
	{Interface}	'Interface'
	'{'
		('name' name=ID)?
		('comment' comment=ID)?
		//('hasEdges' '{' hasEdges+=Interface ( "," hasEdges+=Interface)* '}' )?
		('Type' ':' sort=[Sort| QualifiedName])
	    ('hasInput' hasInput=[InputPort])
	    ('hasOutput' hasOutput=[OutputPort])
	'}'
;
OutputPort returns OutputPort:
	{OutputPort} 
	'OutputPort' name=ID '(' 
		('Type' ':' outputPrtSrtTyp=[Sort| QualifiedName]) 
		('connects' connects=[InputPort])?
	')'
;
InputPort returns InputPort:
	{InputPort}	
	'InputPort' name=ID '('
		('Type' ':' inputPrtSrtTyp=[Sort| QualifiedName])
	    ('connects' connects=[OutputPort])?
	')'
;
DataTypeAssertion returns DataTypeAssertion:
	{DataTypeAssertion}
	'DataTypeAssertion'
	'{'
		('name' name=ID)?
		('comment' comment=ID)?
	'}'
;
DataTypeSpec returns DataTypeSpec:
	{DataTypeSpec}	
	'DataType' name =ID	'('
		'Sort' (sorts+=Sort ("," sorts+=Sort)*)?
		'Operation' (op+=Operation ("," op+=Operation)*)?
	')'
;
Operation:
	name=ID ':'  (dtInput+=[Sort|QualifiedName] ("," dtInput+=[Sort|QualifiedName])*)? '=>' (dtOutput=[Sort|QualifiedName])?
	//(dtInput+=DTInput ("," dtInput+=DTInput)*)? '=>' (dtOutput=DTOutput)?
;
Sort:
	name=ID
;
btaExpression:
	BehaviorTraceAssertion
; 
BehaviorTraceAssertion returns btaExpression:
	LtlOp '(' asertion=btaFunction ')'
;
btaFunction returns btaExpression:
	btaExpression |
	BA
;
BA:
	inputPortA=[InputPort|QualifiedName] '=' outputPortA=[OutputPort|QualifiedName]
;
acExpression:
	ArchitectureConstraint
;
ArchitectureConstraint	returns acExpression:
	LtlOp '(' asertion=archConstFunction ')'
	//( LtlOp '(' AC ')')? 
	//('act''('Component=[Component|EString]')')?
;
archConstFunction:
	acExpression |
	AC
;
AC:
	InputPort=[InputPort|QualifiedName] '=' OutputPort=[OutputPort|QualifiedName]
;
LtlOp:
	('G' | 'X' | 'F')
;
QualifiedName:
    ID ('.' ID)*
;	
